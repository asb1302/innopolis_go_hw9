# task 3

```go
func MinEl2(a []int) int {
	// только для первичной проверки
	if len(a) == 0 {
		return 0
	}
	if len(a) == 1 {
		return a[0]
	}
	t1 := MinEl2(a[:len(a)/2])
	t2 := MinEl2(a[len(a)/2:])
	if t1 <= t2 {
		return t1
	}
	return t2
}
```

**Шаг 1: Размер входных данных**

Размер входных данных алгоритма – длина массива a, обозначим ее как n.

**Шаг 2: Определите основную операцию алгоритма**

Основная операция алгоритма – это сравнение t1≤t2.

**Шаг 3: Проверьте, зависит ли число выполняемых основных операций только от размера входных данны**

Да, число выполняемых основных операций зависит только от размера входных данных, длины массива n.

**Шаг 4: Составьте рекуррентное уравнение, выражающее количество выполняемых основных операций**

Рекуррентное уравнение можно выразить как:

$$
T(n) = aT\left(\frac{n}{b}\right) + f(n)

$$

Здесь:

a = 2 (две подзадачи)

b = 2 (каждая подзадача имеет размер, вдвое меньший исходного),

f(n) = O(1) (время, затрачиваемое на сравнение двух элементов и возвращение наименьшего)

Поскольку  f(n)=O(1), что меньше, чем n, это соответствует первому случаю мастер-теоремы. Согласно этому случаю:

$$
T(n) = O\left(n^{\log_b a}\right) = O(n) 
$$

Таким образом, временная сложность алгоритма составляет:

$$
O(n) 
$$

## Сравните эффективность алгоритма с предыдущим вариантом.

В алгоритме func MinEl глубина рекурсии равна n, так как каждый вызов уменьшает размер массива на один.

В алгоритме func MinEl2 глубина рекурсии равна log n, так как каждый вызов делит массив на две части. Это значительно меньше, чем в алгоритме 1.

## Попробуйте увеличить скорость выполнения функции, используя инструменты Го.

Для увеличения скорости выполнения функции MinEl2 можно применить параллелизацию

```go
package main

import (
	"fmt"
	"sync"
)

func MinEl2Parallel(a []int) int {
    if len(a) == 0 {
        return 0
    }
    if len(a) == 1 {
        return a[0]
    }
    
    mid := len(a) / 2
    var t1, t2 int
    var wg sync.WaitGroup
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        t1 = MinEl2Parallel(a[:mid])
    }()
    
    go func() {
        defer wg.Done()
        t2 = MinEl2Parallel(a[mid:])
    }()
    
    wg.Wait()
    
    if t1 <= t2 {
        return t1
    }
    
    return t2
}
```

- Вместо выполнения рекурсивных вызовов последовательно, используются горутины для выполнения двух рекурсивных вызовов параллельно.
- WaitGroup синхронизирует завершение обеих горутин перед тем, как функция продолжит выполнение и сравнит результаты.

В случае параллелизации горутинами, сложность алгоритма с точки зрения времени выполнения остаётся O(n), так как каждый элемент массива по-прежнему должен быть обработан хотя бы один раз.